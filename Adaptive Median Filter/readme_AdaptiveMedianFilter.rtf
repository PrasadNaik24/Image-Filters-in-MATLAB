{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang16393{\fonttbl{\f0\fmodern\fprq1\fcharset0 Courier New;}{\f1\fswiss\fprq2\fcharset0 Calibri;}{\f2\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
\pard\widctlpar\sa200\sl276\slmult1\qc\b\f0\fs22\lang9 --------------------------------------------------------------\b0\par
\b\fs36 Order Statistic Filters\b0\par
\b\fs32 Adaptive Median Filter\b0\par
\fs24 Designed by\par

\pard\sa200\sl276\slmult1\qc 1. Prasad Naik (D14B/36)\par
2. Saujanya Waikar (D14B/64)\par

\pard\widctlpar\sa200\sl276\slmult1\qc\b\fs22 --------------------------------------------------------------\b0\fs28\par

\pard\widctlpar\sa200\sl240\slmult1\b -------------------\par
Project Description\par
-------------------\par

\pard\widctlpar\sa200\sl276\slmult1\b0\fs24 The adaptive median filter is a modified version of the median filter. Since the median filter is effective only on images with noise probabilities less than 0.2, it cannot be applied on images with high noise probability. For this reason, the adaptive median filter has been designed. The main feature of the adaptive median filter is that it can change its window size if certain conditions are not satisfied. Adaptive median filter is used to remove salt and pepper noise from an image. \par

\pard\widctlpar\sa200\sl240\slmult1\b\fs28 --------------\par
Software Used\par
--------------\par

\pard\widctlpar\sa200\sl276\slmult1\b0\fs24 MATLAB R2020a (9.8.0)\par
Version 20.0\par

\pard\widctlpar\sa200\sl240\slmult1\b\fs28 ---------------\par
Getting Started\par
---------------\b0\par

\pard\widctlpar\sa200\sl276\slmult1\fs24 The folder \lquote Adaptive Median Filter' contains the following files:\par

\pard\sa200\sl276\slmult1 1. AdaptiveMedianFilter.m\par
2. adpmedfilter.tif\par
3. Original.tif\par
4. readme_AdaptiveMedianFilter\par

\pard\widctlpar\sa200\sl276\slmult1\qj 'AdaptiveMedianFilter.m' is the MATLAB file. 'adpmedfilter.tif' and 'Original.tif' are the image files used in this project and the 'readme' file is the documentation of this project .The user must copy the above mentioned files on their system or on MATLAB Drive if they are running this project in MATLAB Online.\par
NOTE: Before running the file AdaptiveMedianFilter.m in MATLAB, the user must ensure that all the above mentioned files are saved in the same folder. Not doing so will result in failure of the program. \par

\pard\widctlpar\sa200\sl240\slmult1\b\fs28 ----------------\par
Code Explanation\par
----------------\par

\pard\widctlpar\sa200\sl276\slmult1\qj\b0\fs24 The code in 'AdaptiveMedianFilter.m' is explained using the comments written in the program. Therefore, users are expected to refer to the comments in the program file and this readme file for understanding the code. \par

\pard\widctlpar\sa200\sl276\slmult1\b 1. Test Image\b0\par

\pard\widctlpar\sa200\sl276\slmult1\qj The noisy image 'adpmedfilter.tif' is imported using the built-in imread(). As mentioned before, users must save all the files listed above in the same directory.\par

\pard\widctlpar\sa200\sl276\slmult1\b 2. Size of the window\par

\pard\widctlpar\sa200\sl276\slmult1\qj\b0 The filter size or window size is taken as an input from the user. The user is expected to input an integer value. Common window size is 3.\par

\pard\widctlpar\sa200\sl276\slmult1\b 3. Function Call\b0\par

\pard\widctlpar\sa200\sl276\slmult1\qj The function adapmedfilter() is called by passing the window size 'W' and test image 'adpmedfilter.tif' as parameters.\par

\pard\widctlpar\sa200\sl276\slmult1\b 4. Padding the image\b0\par

\pard\widctlpar\sa200\sl276\slmult1\qj The test image is padded using the function padarray(). Image padding introduces new pixels around the edges of an image. The border provides space for annotations or acts as a boundary when using advanced filtering techniques.\par

\pard\widctlpar\sa200\sl276\slmult1\b 5. Size of the padded matrix\par

\pard\widctlpar\sa200\sl276\slmult1\qj\b0 The size of the padded image is obtained for calculation of different values further in the code.\par

\pard\widctlpar\sa200\sl276\slmult1\b 6. Maximum window size\b0\par

\pard\widctlpar\sa200\sl276\slmult1\qj The ability of adaptive median filter to increase the window size on certain conditions gives it an advantage over the median filter. But the window size can be increased only to a certain extent. In this program the window size can be increased only upto 7 and is denoted by the variable Wmax.\par

\pard\widctlpar\sa200\sl276\slmult1\b 7. Output Image\par

\pard\widctlpar\sa200\sl276\slmult1\qj\b0 The 'output' variable is reserved for determining the final result.\par

\pard\widctlpar\sa200\sl276\slmult1\b 8. Window\b0\par

\pard\widctlpar\sa200\sl276\slmult1\qj Once the user inputs the window size, the next step is to group all the pixels in that window. The following code \par

\pard\widctlpar\sa200\sl276\slmult1\qc\b C=paddedimage(i:i+(window-1),j:j+(window-1)); \par

\pard\widctlpar\sa200\sl276\slmult1\qj\b0 groups all the pixels from the given window size.\par

\pard\widctlpar\sa200\sl276\slmult1\b 9. Conversion from 2D to 1D\b0\par

\pard\widctlpar\sa200\sl276\slmult1\qj Variable 'C' is a 2D matrix of the pixel values. The following code\par

\pard\widctlpar\sa200\sl276\slmult1\qc\b D=C(:)';\par

\pard\widctlpar\sa200\sl276\slmult1\qj\b0 converts the 2D matrix into a 1D matrix for further calculations.\par

\pard\widctlpar\sa200\sl276\slmult1\b 10. Sorting Algorithm\b0\par

\pard\widctlpar\sa200\sl276\slmult1\qj The 1D matrix of pixels stored in 'D' are sorted in an ascending order. MATLAB has an in-built function sort() for this purpose but we decided to execute it manually.\par

\pard\widctlpar\sa200\sl276\slmult1\b 11. Minimum value pixel in the window\b0\par

\pard\widctlpar\sa200\sl276\slmult1\qj The variable 'zmin' stores the minimum value pixel i.e. the smallest value from the sorted matrix 'D'.\par

\pard\widctlpar\sa200\sl276\slmult1\b 12. Maximum value pixel in the window\b0\par

\pard\widctlpar\sa200\sl276\slmult1\qj The variable 'zmax' stores the maximum value pixel i.e. the largest value from the sorted matrix 'D'.\par

\pard\widctlpar\sa200\sl276\slmult1\b 13. Pixel at (x,y)\b0\par

\pard\widctlpar\sa200\sl276\slmult1\qj One of the requirements of this filter is to use the center value of the window. The following code\par

\pard\widctlpar\sa200\sl276\slmult1\qc\b k=round((window*window)/2);     \par
zxy=D(k);\par

\pard\widctlpar\sa200\sl276\slmult1\qj\b0 obtains the center value of the pixel in the window and store it in the variable 'zxy'.\par

\pard\widctlpar\sa200\sl276\slmult1\b 14. Calculation of median\b0\par

\pard\widctlpar\sa200\sl276\slmult1\qj Variable 'zmed' stores the median pixel value from the window. The if-else statements have been used because median can be calculated in two ways. One, if there are odd number of quantities, the median is the center value. And two, if there are even number of quantities, the median value is calculated by the taking the average of the two center quantities. \par

\pard\widctlpar\sa200\sl276\slmult1\b 15. Main Algorithm Starts\b0\par

\pard\widctlpar\sa200\sl276\slmult1\qj From here, the main algorithm of the adaptive median filter begins. First, the quantities 'A1' and 'A2' are calculated. Then, on the satisfaction of the if condition, 'B1' and 'B2' are calculated which initiates the inner if-else condition statement. \par
If the outer 'if' condition related to 'A1' and 'A2' is not satisfied, the else condition is executed. In the else condition, the size of the window is increased by 1. If the window size in less than or equal to the maximum window size 'Wmax', the function adapmedfilter() is run again with testimage and the new window size as the input parameters. \par
In this manner, the different stages of the algorithm are executed depending on the conditions. \par

\pard\widctlpar\sa200\sl276\slmult1\b 16. Main Algorithm Ends\b0\par

\pard\widctlpar\sa200\sl276\slmult1\qj Here, the main algorithm of the program ends.\par

\pard\widctlpar\sa200\sl276\slmult1\b 17. Converting the output image into uint8 format\par

\pard\widctlpar\sa200\sl276\slmult1\qj\b0 The output image obtained after running the main algorithm is converted into uint8 format using the uint8() function.\par

\pard\widctlpar\sa200\sl276\slmult1\b 18. Displaying the result\b0\par

\pard\widctlpar\sa200\sl276\slmult1\qj The original image, noisy image and the output image are displayed as the output of the program. \par

\pard\widctlpar\sa200\sl240\slmult1\b\fs28 --------------------\par
Running the Program\par
--------------------\b0\par

\pard\sa200\sl276\slmult1\qj\fs24 1. In MATLAb, go to the editor tab and click Run.\par
2. In the command window, you will be prompted to enter the window size. Enter the window size less than 7(Wmax).\par
3.On pressing enter, an output window will appear showing the result of the program.\fs22\par

\pard\sa200\sl240\slmult1\qj\b\fs28 ----------------\par
Acknowledgements\par
----------------\par

\pard\sa200\sl276\slmult1\qj\b0\fs24 We thank Mr. Mrugendra Vasmatkar, Professor, Electronics and Telecommunication Department, VESIT for assigning us this project, which helped us to improve our MATLAB skills and helped in the understanding of the concept of filters.  \b\fs28\par

\pard\widctlpar\sa200\sl276\slmult1\b0\fs22\par

\pard\widctlpar\sa200\sl276\slmult1\qc  \par

\pard\widctlpar\sa160\sl252\slmult1\f1\lang1033\par

\pard\sa200\sl276\slmult1\f2\lang9\par
\par
}
 